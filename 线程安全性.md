线程安全性
=============
要编写线程安全的代码, 核心在于对状态访问操作进行管理, 特别是对**共享**的和**可变**的状态的访问

什么是线程安全性
----------
* 当多个线程访问某个类时, 不管运行时环境采用任何调度方式或者这些线程将如何交替执行, 并且在主调代码中不需要任何额外的同步或协同, 这个类都能表现出正确的行为, 那么这个类就是线程安全的

> 在线程安全类中封装了必要的同步机制, 因此客户端无须进一步采取同步措施

* 无状态对象一定是线程安全的

原子性
---------
在并发编程中, 由于不恰当的实行时序而出现不正确的结果是一种非常重要的情况, 叫做**竞态条件**(Race Condition)

### 竞态条件 ###

当某个计算的正确性取决于多个线程交替执行的时序时, 那么就会发生竞态条件.
> 最常见的竞态条件是先检查后执行(Check-Then-Act)操作, 即通过一个可能失效的观测结果来决定下一步的动作

### 示例: 延迟初始化中的竞态条件 ###
**Check-Then-Act可能失效, 返回错误的引用**

	public class LazyInitRace {
		private ExpensiveObject instance = null;
	
		public ExpensiveObject getInstance() {
			if (instance == null)
				instance = new ExpensiveObject();
			return instance;
		}
	}

### 复合操作 ###
Check-Then-Act和Read-Modify-Write等操作成为复合操作: 包含了一组必须以原子方式执行的操作以确保线程安全性

> 形如i++的操作可以使用线程安全类AtomicLong来管理

> 在实际情况中, 应尽可能地使用现有的线程安全对象来管理类的状态. 与非线程安全的对象相比, 判断线程安全对象的可能状态及其状态转换情况要更为容易

加锁机制
--------- 